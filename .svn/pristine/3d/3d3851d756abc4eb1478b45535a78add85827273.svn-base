#include <linux/module.h>
#include <linux/vermagic.h>
#include <linux/compiler.h>

MODULE_INFO(vermagic, VERMAGIC_STRING);

struct module __this_module
__attribute__((section(".gnu.linkonce.this_module"))) = {
 .name = KBUILD_MODNAME,
 .init = init_module,
#ifdef CONFIG_MODULE_UNLOAD
 .exit = cleanup_module,
#endif
 .arch = MODULE_ARCH_INIT,
};

static const struct modversion_info ____versions[]
__used
__attribute__((section("__versions"))) = {
	{ 0xc01e165c, "module_layout" },
	{ 0xe914e41e, "strcpy" },
	{ 0xc1db3fc7, "gpHalGpioGetValue" },
	{ 0x84b183ae, "strncmp" },
	{ 0x97255bdf, "strlen" },
	{ 0x1655316b, "gp_adc_read_timeout" },
	{ 0xd569d470, "gp_board_malloc_pin_conf_entry" },
	{ 0x872927b8, "down_timeout" },
	{ 0xd0fe2f4, "down_trylock" },
	{ 0xe707d823, "__aeabi_uidiv" },
	{ 0x4f0ea0c0, "up" },
	{ 0xf951c485, "gp_board_free_pin_conf_entry" },
	{ 0x95bb830, "down_interruptible" },
	{ 0xbfe00e81, "gpHalGpioSetPadGrp" },
	{ 0xd87e1440, "kmalloc_caches" },
	{ 0x30b131f7, "__gp_board_get_config" },
	{ 0x29dfed94, "gp_board_register" },
	{ 0xfa2a45e, "__memzero" },
	{ 0xd10f3e5c, "kmem_cache_alloc" },
	{ 0xbebf0810, "gp_adc_start" },
	{ 0x27c6a67f, "gp_adc_request" },
	{ 0x65eb5ada, "gp_pwm_device_register" },
	{ 0x61b246d0, "gp_pwm_release" },
	{ 0x866f4b6d, "gp_pwm_enable" },
	{ 0xc5ea58ff, "gp_pwm_set_config" },
	{ 0xcf977d94, "gp_pwm_request" },
	{ 0xfae39cba, "gp_gpio_set_output" },
	{ 0xbdbf686b, "gp_gpio_set_driving_current" },
	{ 0xc4d3baff, "gp_gpio_set_direction" },
	{ 0x3f815a2f, "gp_gpio_set_function" },
	{ 0xc33e3e20, "gp_gpio_release" },
	{ 0x6bb85351, "gp_gpio_set_pullfunction" },
	{ 0xe5b1a67c, "gp_gpio_request" },
	{ 0x2e5810c6, "__aeabi_unwind_cpp_pr1" },
	{ 0x1c7423d3, "gp_gpio_get_value" },
	{ 0xea147363, "printk" },
	{ 0x37a0cba, "kfree" },
	{ 0xefd6cf06, "__aeabi_unwind_cpp_pr0" },
};

static const char __module_depends[]
__used
__attribute__((section(".modinfo"))) =
"depends=gp_pwm_module";


MODULE_INFO(srcversion, "B61CF40105320C2AD409E9A");
